Circular Language Broader View | Exchangeability
================================================

`[ Draft ]`

The *Exchangeability Principles* describes things in the area of computer technology, that are traditionally separate, that might be combined to form one thing.

Perhaps a central goal of the Circular programming language might be, to melt together computer technology disciplines, aiming to provide one clear language, that might express anything, and that everybody might understand. The *Extensibility Principles* may give shape to these hopes for the language.

This contents page might try to give a definition of each of the exchangeability principles of Circular programming language. More principles might be added in the future.

Some of these articles are not finished yet. The *Exchangeability Principles* folder may contain the following articles:

- ## [Diagram & Text Code Expression](diagram-and-text-code-expression.md)

    - The idea is, that systematics can be fully expressed in text as well as in diagrams. The diagram code might not have anything missing it is: any aspect from the biggest outline to the finest detail can be clearly expressed with the diagram notation. The way storage of systematics as binary interlinked objects is separated from text code and diagram expression.

    - (This article is not finished yet.)

- ## Object Oriented = Relational

    - This article has not been written yet, but it should contain a description about how relational database is reconciled with object oriented programming. The two could always be combinedly used, but it has always been a problem to make the two really one system. They were always just two separate systems, that are conjoined. Circular might turn the two principles into a single paradigm. The object oriented approach and the relational database approach, which are traditionally separate things, are turned into one language. This is intrinsic to the new design of the language. It has not been fully established yet in the programmed versions of Circular.

    - (There may not be a separate article for this yet.)

- ## [Data = Code](data-is-code.md)

    - This fundamental principle is about the fact that a program might *not* consist of commands operating on a database. Your program primarily is the database. Code is just inserted into the data structure, to become part of it.

- ## [Programming Language = Database](programming-language-is-database.md)

    - This fundamental principle is about the fact that the code of a program is stored as a database. *Code is just data*, that describes a process.

- ## [Design Time = Run Time](design-time-is-run-time.md)

    - In most programming languages there is a distinction between design time and run time. This means, that the software is programmed first, and then run. You only run it after you programmed it. If the program it is not error free, the program may crash. The principle *Design Time = Run Time*  takes away this distinction between design time and run time. This article demonstrates how you can create a program and use it at the same time. It goes too much into what happens when an error occurs. That should be covered later in *Errors & Warnings* and in *Concurrency*.

- ## [User = Programmer](user-is-programmer.md)

    - There is no distinction between design time and run time anymore. This makes programming software and using software blend together. Perhaps not everything might be easy to understand to every user, but the lines between creating a program and using a program might fade. The language, with which a user operates the computer, might be the same language, with which you program software. This article further goes into this concept.

- ## [Clear Cut Coding Principles](clear-cut-coding-principles.md)

    - The idea behind clear cut coding principles, is that Circular is so accessible, that even children could pick it up, because the principles are so easy to understand, and there are not that many pitfalls. The basic parts of the coding principles could be picked up by anyone, but more advanced subjects need to be left out, because they can not be understood that easily. It is the intention for a running version of Circular to have sort of like a scale, a slider, that can be adjusted, limiting the amount of concepts expressed in the diagram or textual language, so that complex systems can be expressed using easier concepts, so that the general workings of a system are accessible to anyone.

- ## [Attributes Are Objects](attributes-are-objects.md)

    - In traditional object oriented programming languages and relational databases simple data types, which also may be called *attributes*, might not be considered objects. They have such different behavior, that they might be approached differently from objects. In Circular, however, simple objects such as numbers and dates might always be objects. There are a couple of special characteristics to *simple* objects, that may be explained in the *Objects* documentation. Unifying attributes with objects may make Circular’s grammar less complex.

- ## [Command = Executable Object](command-is-executable-object.md)

    - Even more programming constructs might be turned into just objects. Methods, functions, procedures, routines, commands, executables, all called *commands* in Circular, are actually objects too. Every command might be a special object, that just happens to be executable. A whole chapter has been devoted to it: the *Commands* chapter. The differences between commands and normal objects are explained in it, but the essence of it is: commands might just be *objects*, *executable objects*. Turning commands and objects into the same construct may make Circular’s grammar less complex.

- ## [Hand Signs](hand-signs.md)

    - The diagram notation is so clear and expressive in its forms and shapes, that you can even draw out the shapes *in the air* to clarify systematics. Circular also is a hand sign language for technology.

    - (This article is not finished yet.)

- ## [Hand Writing](hand-writing.md)

    - Also: the diagrams can be drawn with a pencil on paper, so when you have a sheet of paper, you can also clarify the systematics of something using the diagram notation or draw out a quick sketch of systematics. However, a computer can more easily organize the diagram: you can quickly get a mess on a piece of paper, where a computer can automatically organize the diagram shapes.

    - (This article is not finished yet.)

- ## Hardware & Software

    - Circular might reveal the connection between object logic and the physical hardware. It might reveal the internal workings of a computer. It might connect logic to electronics.

    - (There may not be a separate article for this yet.)
    
- ## Multi-Language

    - A model might be come up with for making identifiers in code and translated texts for the user a unified thing. Also error messages might be made more readable and multi-lingual or unified with the user experience in some way. This to try and uphold the idea that a user and a programmer should be much more alike.

- ## System Engineering = Software Engineering

    - That way, Circular allows hardware and software developers and system engineers to work using the same language.

    - (There may not be a separate article for this yet.)

- ## [Internet as a Single Computer](internet-as-a-single-computer.md)

    - This document describes how the internet is turned into a single computer. There simply is no difference between a program running on your own machine and programs running on another machine on the internet. The internet is just used as one giant computer, that everybody uses and contributes to.

    - This document has been moved to the *Infrastructure* documentation, because it might not be part of the first versions to come of Circular.

    - The documentation is quite lengthy and might later be split up into multiple pieces. No software has been developed for it yet.

- ## [Hyperlinks = Referential Structure](hyper-links-is-referential-structure.md)

    - This fundamental principle shows how to view hyperlinks in Circular. Hyperlinks are still part of a textual document, but they can also be seen as analogous to *object structures*, because they are about documents with references to other documents inside it, which is like objects with references to other objects inside it. So this fundamental principle explains how hyperlinks are exchangeable with referential structures, that can be visualized with Circular.

- ## [Flat & Structured Interchange Loose Ideas](flat-and-structured-interchange-loose-ideas.md)

    - The *Flat & Structured Interchange* principles are a set of principles, that turn something flat and unstructured into something branched out and structured. It also can approach anything structured as something entirely flat. Flat and structured are completely exchangeable. Some aspects of the system are not structured by a human being anymore. The system gets structured automatically. For instance: you can not control the containment structure of objects manually anymore. The containment structure is automatically derived from the referential structure of objects.

    - (This article is not finished yet.)

- ## [User Interface Not Command Oriented](user-interface-not-command-oriented.md)

    - Programming interfaces have gone from procedural to object oriented. Commands are part of an object, rather than separate commands being executed on data. User interfaces, however, are still too much *command* oriented, because there are commands in a menu, instead of being able to right-click on an object and see any action you can undertake on it. Any command you can execute on an object should be listed under the context menu of that object. I first and foremost want to see a command hanging under an item, not look through a big list of commands to find the one, I can execute on my item. However, in the new system, all commands you can execute on an object, are accessible under the object itself. But also: all commands of all classes of objects are accessible as a flat list of commands. So the new system actually supports both views. Both views are exchangeable.

- ## [Symbol = Creator](symbol-is-creator.md)

    - This principle partly confirms the *Object Oriented = Relational* principle. *Symbol*  refers to an object oriented programming language I began to construct around the year 2001. It is a programming language, that can fully express a program in a diagram. *Creator*  refers to a programming language I began working on around 2006. The basic principle of it is, that you start off defining classes and relations, and an application is generated out of it. The principle of *Symbol = Creator* is about turning these two languages into a single programming language. This is hard, because *Creator* is based on defining *relations*, and *Symbol* was an object oriented language about a diagram notation, which on top of it all had no way to express a *relation*. This article explains how the two might be combined in the new design, to form a single language.

- ## [Exchangeability Loose Ideas](exchangeability-loose-ideas.md)

    - Loose ideas not yet given a place.