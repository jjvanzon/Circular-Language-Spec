Encircle Language | Broader View
==============================

Automatic Object Formation
--------------------------

`[ Preliminary documentation ]`

If you program something purely procedural,  
but you use the data as parameters,  
the parameters become classes which have this method  
 with the principle of 'Methods and classes loosely coupled'.

But what if the data is not parameters, but data in a god-object?

You could invent a flat & structured interchange concept for this: The usage of god-data in a method will group data together. The USAGE of the data groups the data together to form objects. Then the usage of these objects will add the method to the class.

The usage of data grouping data together, would mean: automatic classing or automatic object formation... or something. That is a new flat & structured interchange concept.

One of the goals of Flat & Structured Interchange is for programs programmed in a very very flat style, to be automatically converted to a program as structured as any well-structured program.

Flat programs can be made as such, when programmers are unaware of the benefits of using classes, unaware of how to program in classes, or the program can just be programmed a very long time ago, when nobody was programming in classes. It automatically gets converted into a system of classes, with methods that can be supported by multiple classes.

Because of the goal of Flat & Structured Interchange, you have to consider a flat set of procedures and a god object with data and how it converts to a structured program. You'd also have to consider spaghetti, and how this can be converted to a well-structured program.

JJ 

-----

Automatic Object Formation,  
2009-05-02

This is also a concept, that is considered to go too far for now. It is about automatically converting unorganized code and data into well-structured code and data organizing it into objects, so that even when you would program something in an unstructured way, it can be automatically converted into a sound structure. This would be handy for trying to understand crap-code, or for reverse engineering compiled machine instructions, or to detect possible improvements to the structure of your code, maybe for deciphering the workings of a formed neural network. Maybe in the future you will not program in a structured way yourself anymore, but you just let the computer figure out the best way to structure the system. All in all, this goes too far for now, but it is something that needs to be thought through in the future.

JJ