Encircle Language | Broader View
================================

Artificial Intelligence, Natural Language, Neural Networks, Object Algebra
--------------------------------------------------------------------------

`[ Preliminary documentation ]`

### Loose Ideas

Men spreekt ervan dat computers moeten kunnen worden geïnstrueerd met gewone taal en dat dat dan een verder ontwikkelde vorm van programmeren is. Maar ik ben het daar niet mee eens. Dit is helemaal niet waar. Je kunt helemaal computers niet op die manier instrueren. Dan krijg je allemaal warrige, onbeduidende, 'ongevere' systemen. Je hebt een formele manier nodig om een computer te instrueren. Je kunt een computer niet goed inrichten met platte taal. Je moet een systeem hiërarchisch inrichten. De bewering dat de toekomstige computertaal moet lijken op gewone menselijke taal, is hetzelfde als zeggen, dat we rekensommen en wiskundige formules ook beter in normale taal kunnen opstellen, en dat dat dan de opvolger is van dingen uitdrukken in formules.

JJ

-----

Een verre toepassing van Creator zou misschien wel menselijke taal om kunnen zetten in iets waar de computer wat mee kan. Daarbij moet de computer echter een referentiekader krijgen, waarin heel veel dingen bekend zijn. Bijvoorbeeld het woord boom. Slechts de structurering van een boom, zit in de computer. De werkelijke betekenis niet. De biologische verhouding, wat allemaal een boom is. Wat voor kleuren. Etcetera. Al deze informatie zit dan in het systeem.

De uitgesproken zin, wordt grammaticaal ontleed. Daardoor staan een referentiele verhoudingen tussen de verschillende elementen van de zin. Ook worden werkwoorden (Methods), zelfstandige vormen (Objects) en bijvoeglijke bepalingen (Attributes) bepaald. Werkwoorden (methods) kunnen ook zelf een object zijn, met een execute method, en referenties naar verschillende dingen. Zo kan een object geörienteerde referentiele structuur worden gevormd. Deze vertaalt zich automatisch naar een encapsulatie structuur. Die kan dan zichtbaar worden gemaakt op scherm in symbolen. Bepaalde constructies in de zinnen geven al structuur aan. De begrippen die je vind in de zin (handelingen, objecten en eigenschappen), kunnen zelf structuur inherent in zich hebben. Deze begrippen worden herkend, en in een databank staat de structuur van deze begrippen en waar het begrip allemaal verhoudingen mee heeft.

Daardoor krijg je een soort kunstmatige intelligentie, met een referentiekader en waar verbanden tussen alle dingen kunnen worden gelegd.  
De menselijke taal vertaalt zich naar computer taal. De begrippen worden herkend en linken naar nog meer gerelateerde computer taal. Zo wordt de structuur van de zin gecombineerd met de structuur die elk begrip inherent in zich heeft.

Een probleem is wel dat er wereldwijd heel veel verschillende definities van een begrip kunnen komen, die toch op een of andere manier aan elkaar gelinkt moeten worden. Alles in de wereld moet eigenlijk aan elkaar gelinkt worden als 1 groot computer systeem.

-----

Semantic meanings in symbol.

-----

J Code,

Shared properties are interfaces! You should be easily able to pick a shared property to type your own property with! It is recommended that you adopt the same name, but it is not
mandatory! Identifiers should be multilingual! They'd call this sematic classification!

JJ

-----

Analyzing real language, laying out the limitations, what things can be expressed in language, gives you the possibility to make an information structure out of a sentence or a story. This opens the possibility to have a computer interpret what you mean, because it ‘knows’ what can be expressed in language and can interpret anything. If it can’t interpret something it can still ask how to interpret it and mark it as something learned from the user, to keep those things separated from the delivered language data. It also opens the opportunity to make an information structure based on language aspects: location, person, about, subject. Or something. The computer can make Symbol out of a sentence and can recognize the ‘class’ of a word. Is it an object or a concept, is it a location, direction, etcetera. If it’s a concept, then is it an emotion, a ... or a ... Etcetera, etcetera. If it can build Symbol out of a sentence, then it can build a data record out of a sentence, so a human language sentence can form the base of an information entity. 

So you can translate human language to Symbol.  
Creating containment relations, overlapping containment by references.  
A dictionary can tell the classes of words, giving the words classes.  
Inheritance can be used to give different words the same base class. For instance: ‘sadness’ and ‘unity’ are both ‘concepts’. Both have concept as the base class.

It can create correlations between syntaxes that are semantically correct. That way you can say things in a million ways, and it still will be able to point out a single same meaning of what you say.  
If it encounters ambiguity ...

I’m not saying it’s easy, but if the systematics of language can be defined exactly, then a computer system could be designed to interpret it.

If computers can work with the relations between language elements, it is capable of reformulating sentences. It doesn’t know, however, if the reformulation is good or not. Maybe if you tell it when it’s good and when not, it record the goodness and its context. If it’s told something’s good in similar context, it can record for itself that it might be those context elements that are the same that make it good in the context and that those context elements that differ, are not the thing that influence the betterness of the sematics.

If the computer lays more and more relations between language elements, it might be able to start with a random sentence (symbol structure) and know how to pick next things, picking a random next thing possibilities. That way it can come up with a fantasy story. You can create the suggestion that the computer is actually fantasizing.

See Job Search report for an example of classifying zinsdelen.

JJ

-----

< If a method affects multiple objects, the method does not belong to either of the objects. Unless the object is the subject and it is an active sense. Am I creating a link between logic in human sentences, and logic of programs? >

-----

< Noun and a verb. A method is a verb, an object is a noun. A verb is an action, the nouns are the objects. A noun can be used, or affected. Also, the relation of the object can be expressed by a ~ voegwoord < ? > (in, op, bij, met...). Can I limit the possible relations between words, regardless of their meaning, just like computer programs only really express relations between things, regardless of their meaning, and the meaning is just in the imagination of the human being? Perhaps you just have to investigate what possible logical relation an object can have with an action, to be able to see how to couple methods and classes automatically. >

-----

< Perhaps the way the object is used by the method, creates a stereotype, analogous to our human language grammar. Onderwerp, leidend voorwerp, meewerkend voorwerp en allerlei bijwoordelijke bepalingen, might be determined by the fact if a parameter is read, written, read and written, only transferred to other methods, state written, state read, member written, member read... 

-----

J Code, Natural Language

Taal is een afgrijselijk seriele manier om verbanden tussen dingen aan te geven. Als ik het verband tussen drie dingen aan wil geven, moet ik soms heel erg nadenken over hoe ik het formuleer. Zeg ik eerst A, dan B, dan C of eerst A, dan C en dan B. De twee dingen die het verst uit elkaar staan, daar druk je het verband minder sterk van uit. Of misschien moet je het opsplitsen in meerdere verbanden en elk verband apart noemen.

JJ

-----

Flat & Structured Interchange,

Automatic object formation zou uber-cool zijn. Bij een goede flat & structured interchange, zou je complexe referentiële structuren helemaal om kunnen zetten naar een goed gestructureerde object structuur. In theorie ook neurale netwerken terug kunnen engineeren naar een object structuur.

Je zou dit als bij-doel moeten hebben voor Flat & Structured Interchange.

Je zou Flat & Structured Interchange moeten aanvullen met nieuwe principes, om het zo volledig te krijgen, dat een complexe referentiële structuur volledig om te zetten naar
een object structuur, het liefst waar alle object concepten
goed gebruikt zijn. Je zou het ook zo kunnen maken, dat je dit als uiteindelijk doel stelt, maar Flat & Structured Interchange niet helemaal volledig maakt hiervoor. Je zou dan ook moeten definiëren waartoe je het doel dan wel beperkt. Misschien is het een niet-logisch doel, maar slechts een opsomming van een aantal principes die volledig worden uitgewerkt, terwijl andere principles slechts als suggestie blijven bestaan, en de means of de bijdoelen niet eens worden gespecificeerd.

Je hebt echter de kans dat je weer Flat & Structured Interchange dingen tegen komt, die de taal volledig door de war kunnen gooien. Misschien moet je daar ergens een grens gaan trekken, om toch de huidige ideeën adequaat uit te werken, en niet te veel nieuwe ideeën meer uit te werken, en slechts de ideeën uit te werken, die noodzakelijk zijn voor het bereiken van het doel.

Je moet het doel aanscherpen: je moet zeggen onder welk mom niet uitgewerkte ideeën uitgewerkt moeten worden. Andere ideeën zouden nog niet uitgewerkt mogen worden.

Inwisselbaarheid van object georiënteerd en referentieel en neuraal en semantiek, kan computer language maken tot een intermediaire taal voor nog meer systemen, dan alleen computer systemen.

JJ

-----

Neural networks,

Neural networks adapt themselves beyond the control of human beings. To give control back to humans, the complex referential structures of the Neural Networks should be automatically reverse engineered to structured object structures, that can recompile back to the neural network structure again.

JJ

-----

Flat & Structured Interchange, Automatic Object Formation, Neural Networks,

To subdivise in classes, you have to recognize patterns, or phenomena.

JJ

-----

Flat & Structured Interchange,

Don't forget to mention reverse engineering machine code to object oriented systems, that might be better structured than the original code, or restructuring existing object oriented programs, so not only procedural programs, also restructuring object oriented programs to become better. Simply convert everything to a flat referential structure and then convert it to an object structure.

JJ

-----

Computer Language,

Bij diagram notatie bestaat alles uit verbindingen, in plaats van code regels. Misschien kan je makkelijker rekenen met die verbindingen en 1 wiskundige benadering maken, van de objecten.

JJ

-----

Computer language algebraic approach,  
2008-07

If you can’t automatically make assumptions about the execution order of sub-commands, can you define a precedence of parameter passing, based on likeliness, like in algebra? Can you then affect the execution order with something like parenthesis, like in algebra? I WAS going for something about connections between objects and commands, that can be algebraically approached, and solved like an equation, so maybe there is a key there. Perhaps such algebraic approach would help in concurrency resolution as well.

You might make a default assumption about a dependant reading command wanting the clean, unaltered value, but maybe not.

Also look at ‘parameters of calls directly tied together, because it contains interesting ideas about dependency and perhaps ideas about defining execution order in an algebraic way with parenthesis.

JJ

-----

Object Algebra

Do you want  
Creator  
to have a  
Mathematical Foundation  
?

JJ

-----

Consider this for object algebra:  
< I have to define a system that returns  every possible 
tie-together of objects. > I SHOULD REALLY CONSIDER THIS.

-----

2004,

Nouns are objects, verbs are methods and adverbs are properties. Hmmm... the study of language and grammar will extend the symbol language.

JJ