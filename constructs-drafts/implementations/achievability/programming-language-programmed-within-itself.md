Construct Drafts | Implementations | Achievability | Programming Language Programmed Within Itself
==================================================================================================

`[ Out of Scope ]`

__Contents__

- [Introduction](#introduction)
- [The Six Layers](#the-six-layers)
- [Layer 1: The ccc-Layer](#layer-1-the-ccc-layer)
- [Layer 2: The gcc-Layer](#layer-2-the-gcc-layer)
- [Layer 3: The ggc-Layer](#layer-3-the-ggc-layer)
- [About The Layers Up Until Now](#about-the-layers-up-until-now)
- [Layer 4: The ggg-Layer](#layer-4-the-ggg-layer)
- [Generic & Non-Generic Classes](#generic--non-generic-classes)
- [Summary of Layers 1 - 4](#summary-of-layers-1---4)
- [Layer 5: The pgg-Layer](#layer-5-the-pgg-layer)
- [The ggg-Layer Not Required](#the-ggg-layer-not-required)
- [Layer 6: The ppg-Layer](#layer-6-the-ppg-layer)
- [Summary Of The Layers](#summary-of-the-layers)
- [Parsed Layers Not Required](#parsed-layers-not-required)
- [Indirection On Class Assignment](#indirection-on-class-assignment)
- [No Indirections On Object Access](#no-indirections-on-object-access)
- [How Data Is Stored](#how-data-is-stored)
- [Layer 7 Is For Fun](#layer-7-is-for-fun)
- [Slowing Down On Each Added Layer](#slowing-down-on-each-added-layer)
- [Loose Ideas](#loose-ideas)

## Introduction

*(This article also covers subjects about the implementation of the code base.)*

Software development projects take a lot of time. Think of how much you might test for even a smaller project. I have seen it in some of the projects I did at home, such as Finney and Music Thumper. Using the normal way to develop software it is impossible to create the amount of software, that I want to create all by myself.

But Circular is so powerful, that you *can* make this software all by yourself. However, creating its programming environment is a huge project in itself, that you can not do alone using the normal way of making software. This was proven by my trying to make experiment 0.9, which took about one and a half years, and still it wasn’t finished. The only way I am going to create such a programming environment on my own, is to program the programming environment using Circular itself.

My ideas about a computer language programmed within itself date from experiment 0.9, which was a code generator. It might be possible to regenerate part of the code generator. The part, that actually *generated* the code could *not* be regenerated. But the part with which you describe a program, could be regenerated by the code generator itself. This way, features added to the code generator might also be reflected in the module with which you describe a program, features which you could then use again inside the code generator.

Experiment 2.0 might no longer be a code generator. They are generic modules or engines that can load a program description, and have the program run inside it.

For a while it wasn’t clear how I might implement the principle of programming Circular within itself in the engine-version of Circular, because of the paradox of having an engine run within itself.

The trick is to have a small code base that offers the basic language, and use this code base to program the rest. The deepest part of Circular might always be a small code base written in another language (for instance C++ or Assembly).

It turns out you might redescribe the code base six times, using its predesessing module, until you are able to describe the module in the exact same way the predesessing module is described.

When adapting the module again, you are programming it using a previous version of the module. Strict and robust version control is used to keep that manageable.

The system might always be running on a code base written in an older Circular, but this code base might be very small. The topmost version of the engine, might be decorated with numerous features, but the engines below that might always have the most limited amount of features required to rewrite that engine using itself.

The fact that this works, has already been proven with experiment 2.0.

So in order to describe the computer language using the same computer language, you actually need a set of six engines running on top of each other.

## The Six Layers

In order to program the Computer Language within itself, you may need to redescribe it six times, every time using the previous description as the programming language in which to program the next description.

## Layer 1: The ccc-Layer

The 1st layer is programmed in C++. The first piece of its code roughly looks like this:

```c++
class CStructure {
    CClasses\* Classes ;
    CRelations\* Relations ;
} ;
```

The code above can be used for describing *structure* of data. An actual *item of data* is represented by a CItem object:

```c++
class CItem ;
```

The first layer is also called the ccc-layer. Each c stands for C++. It means that the structure of the program above, the code, and the usage is all done in C++. With each layer things might gradually shift towards Circular. At this point everything is still C++.

The class CItem is not really part of the ccc-layer. CItem objects might still be used in the topmost layer, only the *class description* for a CItem object might be different in each layer. CItem objects are not considered C++ objects, they are considered Circular objects.

## Layer 2: The gcc-Layer

The 2nd layer is programmed using the ccc-layer. The 2nd layer is also called the gcc-layer. The first bit of its code looks something like this:

```c++
gccStructure = cccClasses . Add ( ) ;
gccClass = cccClasses . Add ( ) ;
gccRelation = cccClasses . Add ( ) ;

gccStructureToClasses = cccRelations . Add ( ) ;
gccStructureToClasses . RelationClassA = gccStructure ;
gccStructureToClasses . RelationClassB = gccClass ;

gccStructureToRelations = cccRelations . Add ( ) ;
gccStructureToRelations . RelationClassA = gccStructure ;
gccStructureToRelations . RelationClassB = gccRelation ;
```

The 1st layer is used here to describe the same system again. The 2nd layer is called the gcc-layer.

- The first g stands for *generic*. When you use the engine above, you might describe classes in a more generic way as CItem objects rather than CClass objects. CItem objects are considered Circular objects, not C++ objects.
- In first c stands for C++, and the fact the engine itself is described using C++ objects (CClass objects).
- The second c stands C++, and the fact that the *reflective data* of the objects this layer is built up of, is merely the C++ code of the ccc-layer.

At this point the language is already redescribed within itself, but the descriptions *look* totally different. Redescriptions continue until the next description looks exactly like the previous description.

## Layer 3: The ggc-Layer

So then, the 3rd layer is described using the 2nd layer. It is called the ggc-layer. You’d better skip over the first line of code when, when you read it for the first time:

```c++
gccStructure . Class = gccLayer . gccStructure ;

ggcStructure = gccClasses . Add ( ) ;
ggcClass = gccClasses . Add ( ) ;
ggcRelation = gccClasses . Add ( ) ;

ggcStructureToClasses = gccRelations . Add ( ) ;
ggcStructureToClasses . RelatedItems . Item ( "gcc Relation Class A" ) = ggcStructure ;
ggcStructureToClasses . RelatedItems . Item ( "gcc Relation Class B" ) = ggcClass ;

ggcStructureToRelations = gccRelations . Add ( ) ;
ggcStructureToClasses . RelatedItems . Item ( "gcc Relation Class A" ) = ggcStructure ;
ggcStructureToClasses . RelatedItems . Item ( "gcc Relation Class B" ) = ggcRelation ;
```

This is where objects no longer have C++ *classes*, but a C++ *object* for a class.  
The first line assigns the Structure class to the Structure object.  
The layer is called the ggc layer. The first g stands for *generic*. When you use the engine above, you might describe classes in a more generic way as CItem objects. CItem objects are considered Circular objects, not C++ objects. The second g also stands for generic. For the first time the engine itself is described as CItem objects, which are not considered C++ objects, but Circular objects. The third letter, the letter c stands for C++ and the fact that the *reflective data* of the objects used above, are still CClass objects of the ccc-layer, which are considered C++ objects, rather than Circular objects.

I guess I have made clear, that it is important to understand that CItem objects are *not* considered C++ objects but generic Circular objects.

## About The Layers Up Until Now

The first layer is the absolute minimum Circular might contain. In the second layer you build up a generic version of it, but it’s still described in a way, you couldn’t describe it in Circular itself. The third layer is programmed in a way, you could program it in a Circular programming environment. So this layer could be reprogrammed in a Circular programming environment.

The bottom layers might only contain the absolute base of the systematics of Circular: Circular in its most primitive form, just enough to redescribe it. All the extensions are added to the top layer, which can be reprogrammed within the Circular programming environment.

In theory, you could directly program the running programming environment. So in realtime you are programming the program you are programming in. Very cool, but not very practical, because if you mess up the program, you have also directly messed up the environment you were programming in. So you are going to want to use an older version of the programming environment, to make a new version with. The new programming environment can replace the older version. So you can reprogram the topmost layer within Circular itself.

A part of Circular might never be reprogrammed within itself. In experiment 0.9, the generator experiment, the generator itself was also never regenerated, only the part with which you describe a program. The absolute base of Circular might always be ‘hand written’.

## Layer 4: The ggg-Layer

The 4th layer is called the ggg-layer and looks almost exactly the same as the 3rd layer, except for the first line of code.

```c++
ggcStructure . *GenericClass* = ggcLayer . ggcStructure ;

gggStructure = ggcClasses . Add ( ) ;
gggClass = ggcClasses . Add ( ) ;
gggRelation = ggcClasses . Add ( ) ;

gggStructureToClasses = ggcRelations . Add ( ) ;
gggStructureToClasses . RelatedItems . Item ( "ggc Relation Class A" ) = gggStructure ;
gggStructureToClasses . RelatedItems . Item ( "ggc Relation Class B" ) = gggClass ;

gggStructureToClasses = ggcRelations . Add ( ) ;
gggStructureToClasses . RelatedItems . Item ( "ggc Relation Class A" ) = gggStructure ;
gggStructureToClasses . RelatedItems . Item ( "ggc Relation Class B" ) = gggRelation ;
```

When adding items, under the surface, an item gets assigned a class, upon which the item configures itself according to the class description. Only one of the assignments of a class is explicitly visible in the code above: the first line: assigning the Structure class to the Structure object.  
In the 3rd layer it was a C++ object describing the class. In the 4th layer it is a Circular object describing the class. So in this layer, the class descriptions used, are Circular objects, whereas in the previous layer the class descriptions used, were C++ objects.  
After class assignment, an object looks the same in both layers.  
The first g in ggg-layer stands for generic: the fact that the engine above might be used specifying Circular objects. The second g in the ggg-layer also stands for generic, but now because the engine itself is built up of generic CItem objects. The third g in the ggg-layer stands for generic, but now the fact that the reflective data of every CItem object used in the code above, is also a generic Circular object.

So the three letters always indicate:

- Its usage
- Its objects
- Its classes

## Generic & Non-Generic Classes

So there are two commands in a CItem object that adapt the CItem to its class: one that takes a CClass object, that describes the class using a C++ object, and one that takes a CItem object, that describes the class Computer-Language-style.

## Summary of Layers 1 - 4

- So layer 1 provides a C++ way to define structures.
- Layer 2 describes Circular again, using C++ CClass objects.
- Layer 3 assigns these C++ CClass objects to CItem objects, and describes Circular in CItem objects, instead of CClass objects.
- Layer 4 also consists of CItem objects, but the assigned classes are CItem objects themselves.
<br/><br/>
- So in the 1st layer everything is C++.
- In the 2nd layer things are CClass objects.
- In both the 3rd and the 4th layer, everything is described using CItem objects.
- The difference between the 3rd and 4th layer is, that in the 3rd layer the assigned classes are CClasses, and in the 4th layer the assigned classes of are CItems.

## Layer 5: The pgg-Layer

The 5th layer consists of custom text code, for which a text code parser is programmed. This layer is called the pgg-layer. The p stands for *parsed*. The text code is translated to a structure that is the same as the previous layer, but this is done with a custom text code as input and the output coming out of the parser. This custom text code looks something like this:

```vb
Class  Structure
Class  Class

Structure  (  Structure  )    1  -->  n    Class  (  Classes  )
Structure  (  Structure  )    1  -->  n    Relation  (  Relations  )
```

The parser might translate it to the same data as in the previous layer. But in this layer more features are added, because it is so much easier to add more features using this custom text code. So here it is, where all the extra features are added, that were left out in the layers before. It is in this layer, that you can really see that the Circular is being programmed within itself. And this is where it gets so much easier to program more features.  
The two g’s in the term pgg-layer stand for *generic* in the fact that the engine is still built on top of non-parsed Circular objects, with non-parsed Circular objects as reflective data.

## The ggg-Layer Not Required

The parser could (probably) also have used the 3rd layer instead of the 4th layer. The 4th layer might not even be required. It dates back to when there was no custom text code in any of the layers yet, and the 4th layer was the outermost layer in which the description of the system is exactly the same as the previous description. But now the 4th layer isn’t an end-point anymore, so it can be skipped.

## Layer 6: The ppg-Layer

There’s also a 6th layer. The code of it, is exactly the same as the 5th layer. The deal is that the extra features, that are in the text code, were added to the *objects*, but the extra features were not present in the *class descriptions* of the objects. So the objects themselves had extra elements, but their reflective data did not. To make the reflective data of the engine as rich as the objects themselves, the parser might build up the structure again using the 5th layer as reflective data, which also has all the rich features  present in it. The 6th layer is also called the ppg-layer. It is the topmost layer.

## Summary Of The Layers

A summary of all the layers:

- ccc-layer:
    - When you use this engine, you are working with C++ objects.
    - The engine itself is built up of C++ objects.
    - And their reflective data is basically just the C++ code.
- gcc-layer:
    - When you use this engine, you are working with Circular objects.
    - The engine itself is still built up of C++ objects.
    - And the reflective data of the C++ objects, are also C++ objects.
- ggc-layer:
    - When you use this engine, you might be working with Circular objects.
    - The engine itself is also built up of Circular objects.
    - But the class descriptions of the objects the engine is built up of, are still C++ objects.
- ggg-layer:
    - When you use this engine, you might be working with Circular objects.
    - The engine itself is also built up of Circular objects.
    - And the class descriptions of the objects the engine is built up of, are also Circular objects.
- pgg-layer:
    - This engine is described by a custom text code. A parser takes this text code and turns it into an engine. For the rest, things are the same as the ggg-layer.
    - This engine has richer features, but the reflective data of the engine’s objects might not have these rich features.
- ppg-layer:
    - The same as the previous layer, but now the reflective data of the objects the engine is built up of, also has all the rich features in it.

## Parsed Layers Not Required

Disregarding a few things, you don’t need the parsed layers pgg and ppg, if you agree to describe a richer Circular structure layer in the ggc and ggg layers, then you’d have the same engine. But then you’d be programming the engine in C++. You might have much more C++ code to write, and Circular is just much easier to write. It is the practicality that matters here. It is more practical to program using Circular code, so it’s more practical to program Circular using Circular.

## Indirection On Class Assignment

It’s not that each layer adds another layer of indirections to the Circular *objects*. It is the way you describe *classes* that is different in each layer. The *objects* are constructed the same way in most of the layers. Assigning a class to an object goes slower with each engine layer added, because of following more indirections.

## No Indirections On Object Access

The CItem objects are just CItem objects with each an arbitrary number of attributes, related items and related lists. It is only when assigning a class, that it has anything to do with the class description. After the class is assigned it’s just an Item with an arbitrary set of attributes, related items and related lists, independent of the class. It just looks like it conforms to the class it was assigned, but the Item really has no connection with it anymore.

Not regarding the class assignment, the structure even in the highest layer basically consists of CItem objects with arbitrary sets of attributes, related items, and related lists.

## How Data Is Stored

Object access might not have any extra indirections due to the the multiple layers. Data is mostly just stored as Circular objects, that can have an arbitrary set of attributes, related items and related lists.

It’s not the data that is redescribed six times. It is class descriptions, that is redescribed six times. Data are just Items, that can configure themselves using a Class or Generic Class.

In the 1st layer the *data*, that is the structure description, is *the C++ code*. In the 2nd layer the structure description is C++ objects in memory. In the 3rd and 4th layers the structure description actually consists of Circular objects, that can become memory based or disk based data. The data in both layers is pretty much the same. The difference between the 3rd and 4th layer, is that in the 4th layer, the structure/classes of the Circular data are described by yet again Circular data, and in the 3rd layer, the structure/classes of the Circular data are described by memory based C++ objects. The data in the two parsed creator layers on top of that, is also the same, yet richer, because more features are added to the engine programmed in custom text code.

## Layer 7 Is For Fun

For fun you can add another layer, where you describe Circular as Circular data. But this layer might only be there for fun and not *required* nor more practical in order to accomplish Computer Language Programmed Within Itself.

## Slowing Down On Each Added Layer

I used to have a test where I parsed the custom text code of Circular, and then replaced the currently running Circular engine by the one just parsed. It did not give errors, but as I repeatedly parsed and replaced the engine, the system became slower and slower exponentially.

An extra Circular engine layer might not cause extra redirections on item access, but it might cause redirections in the class definitions. These classes were used when looking for an item by name. So that made item access also go slower with each added Circular engine layer too.

To make object access by name not go slower with each engine layer, the name of the object was stored in the object, not just in the class. That ensured the disconnection from the class after class assignment, so that the data had nothing to do anymore with how many layers the engine has. You might still might loop through all the items, to look for an item by name, but not through multiple Circular engine layers anymore, only through one layer. It dramatically improved performance.  
It also speeded up class assignment, because class assignment also looked up items by name.

If you index items purely by number, then you also might not search for names anymore. That might be very nice.

## Loose Ideas

Circular, Code Base

- Rename 'Your' and 'My' to ccc and gcc naming
- Also rename the identifiers in the first layer to ccc
    - \> That might make a lot of code look crappy, because then members such as RelatedItems might always be called cccRelatedItems.  
    What you should do is not apply that naming for the items, only for the structure

JJ

-----

Circular, Code Base

I doubt, that the ggg layer is required.  
I think the pgg layer could also be built on top of the ggc layer.
The reason this layer existed, is because at first there were no p-layers.

JJ

-----

Circular, Code Base

Make the item part of the deepest layer a separate code module, because it is not part of the layering. It is always present.

It is a layering of class descriptions. Actual items of data are always the same regardless of the layer. This is analogous to the generator-version, which could regenerate the module used for structure descriptions, but could not regenerate the part actually generating the code.

JJ

-----

Circular, Code Base

Could I omit Circular layers, by taking the ppg layer and somehow linking it to the gcc layer, and throw away the intermediate layers, so that only 3 layers remain?
I’m not sure.

JJ

-----

- Classes need to be part of the code base in order to rewrite the code base several times.
    - Classes misschien toch niet nodig in code base
        - Als ook de code base geen classes heeft, hoef je classes ook niet te herprogrammeren in lagen daarboven. Pas op het eind implementeren als Aspect?  
        Dit gaat over het onderwerp implementation as an aspect: een ander project. Niet belangrijk nu, wat principle is en wat aspect.

-----

Code Base, Objects,

For relation between objects, you only need two unary relations, that are not synchronized. An object has a list of referrers in it, and an item in it, that says which other object it refers to.

You only need relation between objects for the aspect of classes, if you make the aspect of classes a dual relation: a class also needs to be aware of all the objects that use it as its class.  
If you accept, that a class might not know which objects use it as its class, then you don’t even need relations between objects to be dual. You’s only need sub objects, that refer to another object.

But you already need to implement sub objects and sub lists in the code base in order to have any kind of multiplicity, don’t you?  
Actually, that is not important enough for now. For now it is not important to brainstorm about what is a principle, what is an aspect, and how much needs to be put in the code base.

The code base probably only needs unary relations between objects. The highest layers on top of the code base, can turn this into dual relations between objects, but the lowest layer only needs unary relations.

JJ

-----

Code Base,  
Reference as an Aspect,  
2008-06-23

If a sub object either is a reference, or a value, can a reference be implemented as a binary value. Could the principle of Values facilitate the principle of reference?

It only applies, that a sub-object is either a reference or a value, when an attribute never contains sub-objects, only a value.

JJ

-----

Code Base,

What if a machine instruction becomes a command object with a binaral? The binaral is an instruction executable by the CPU. Might this open up possibilities to take even more out of the code base?

JJ

-----

Code Base,  
2008-06-24

Can you implement reference assignments as calls to machine instructions, executed within the programming language itself?

JJ

-----

Code Base,  
Redirections are established with assignments,  
2008-08-07

< 2008-09-02 This is considered a code base idea, because it makes redirections be able to build on value assignment. >

You might explain how lines or redirections are established with an assignment, and that this happens automatically when for instance, when instantiating objects of a class. The assignment, even though you don’t see it, is executed by the direct mutual parent.

JJ

-----

Computer Language Programmed Within Itself,  
2008-08-27

The code base is the minimal needs, that need to be programmed in another programming language, required to be able to fully reprogram that code base using the new programming language itself.

JJ

-----

Code Base,  
Advanced Command Articles,  
2008-08

When machine instructions are invoked in Circular as calls to Circular commands, that invoke the instruction, then a string of such machine instructions has a real overhead around it. Therefore, pure stretches of assembly commands calls should be packed in a nested command, that gets a binaral that is the exact machine code, compiled as a stretch of binary, instead of separate ‘symbol’ commands. That should take care of the overhead, when writing deep-core assembly stuff.

JJ

-----

You can program at the lowest level from within Circular, because you can call machine instructions and compile a command to a runnable binary. So you could program a kernel using the programming language itself. So a kernel is not required to be able to program a kernel using Circular.