Circle Language Broader View | Achievability Principles
=======================================================

Programming Language Programmed Within Itself
---------------------------------------------

*(This article also covers subjects about the implementation of the code base.)*

Software development projects take a lot of time. Think of how much you have to test for even a smaller project. I have seen it in some of the projects I did at home, such as Finney and Music Thumper. Using the normal way to develop software it is impossible to create the amount of software, that I want to create all by myself.

But the new computer language is so powerful, that you *can* make this software all by yourself. However, creating its programming environment is a huge project in itself, that you can not do alone using the normal way of making software. This was proven by my trying to make Computer Language 0.9, which took about one and a half years, and still it wasn’t finished. The only way I am going to create such a programming environment on my own, is to program the programming environment using the computer language itself.

My ideas about a computer language programmed within itself date from Computer Language 0.9, which was a code generator. It would be possible to regenerate part of the code generator. The part, that actually *generated* the code could *not* be regenerated. But the part with which you describe a program, could be regenerated by the code generator itself. This way, features added to the code generator would also be reflected in the module with which you describe a program, features which you could then use again inside the code generator.

Computer Language 2.0 and Computer Language 3.0 are no longer code generators. They are generic modules or engines that can load a program description, and have the program run inside it.

For a while it wasn’t clear how I would implement the principle of programming the computer language within itself in the engine-version of Computer Language, because of the paradox of having an engine run within itself.

The trick is to have a small code base that offers the basic language, and use this code base to program the rest. The deepest part of the computer language will always be a small code base written in another language (for instance C++ or Assembly).

It turns out you have to redescribe the code base six times, using its predesessing module, until you are able to describe the module in the exact same way the predesessing module is described.

When adapting the module again, you are programming it using a previous version of the module. Strict and robust version control is used to keep that manageable.

The system will always be running on a code base written in an older computer language, but this code base will be very small. The topmost version of the engine, will be decorated with numerous features, but the engines below that will always have the most limited amount of features required to rewrite that engine using itself.

The fact that this works, has already been proven with Computer Language 2.0.

So in order to describe the computer language using the same computer language, you actually need a set of six engines running on top of each other.

### The Six Layers

In order to program the Computer Language within itself, you need to redescribe it six times, every time using the previous description as the programming language in which to program the next description.

### Layer 1: The ccc-Layer

The 1st layer is programmed in C++. The first piece of its code roughly looks like this:

```c++
class CStructure {
    CClasses\* Classes ;
    CRelations\* Relations ;
} ;
```

The code above can be used for describing *structure* of data. An actual *item of data* is represented by a CItem object:

```c++
class CItem ;
```

The first layer is also called the ccc-layer. Each c stands for C++. It means that the structure of the program above, the code, and the usage is all done in C++. With each layer things will gradually shift towards Computer Language. At this point everything is still C++.

The class CItem is not really part of the ccc-layer. CItem objects will still be used in the topmost layer, only the *class description* for a CItem object will be different in each layer. CItem objects are not considered C++ objects, they are considered Computer Language objects.

### Layer 2: The gcc-Layer

The 2nd layer is programmed using the ccc-layer. The 2nd layer is also called the gcc-layer. The first bit of its code looks something like this:

```c++
gccStructure = cccClasses . Add ( ) ;
gccClass = cccClasses . Add ( ) ;
gccRelation = cccClasses . Add ( ) ;

gccStructureToClasses = cccRelations . Add ( ) ;
gccStructureToClasses . RelationClassA = gccStructure ;
gccStructureToClasses . RelationClassB = gccClass ;

gccStructureToRelations = cccRelations . Add ( ) ;
gccStructureToRelations . RelationClassA = gccStructure ;
gccStructureToRelations . RelationClassB = gccRelation ;
```

The 1st layer is used here to describe the same system again. The 2nd layer is called the gcc-layer.

- The first g stands for *generic*. When you use the engine above, you will describe classes in a more generic way as CItem objects rather than CClass objects. CItem objects are considered Computer Language objects, not C++ objects.
- In first c stands for C++, and the fact the engine itself is described using C++ objects (CClass objects).
- The second c stands C++, and the fact that the *reflective data* of the objects this layer is built up of, is merely the C++ code of the ccc-layer.

At this point the language is already redescribed within itself, but the descriptions *look* totally different. Redescriptions continue until the next description looks exactly like the previous description.

### Layer 3: The ggc-Layer

So then, the 3rd layer is described using the 2nd layer. It is called the ggc-layer. You’d better skip over the first line of code when, when you read it for the first time:

```c++
gccStructure . Class = gccLayer . gccStructure ;

ggcStructure = gccClasses . Add ( ) ;
ggcClass = gccClasses . Add ( ) ;
ggcRelation = gccClasses . Add ( ) ;

ggcStructureToClasses = gccRelations . Add ( ) ;
ggcStructureToClasses . RelatedItems . Item ( "gcc Relation Class A" ) = ggcStructure ;
ggcStructureToClasses . RelatedItems . Item ( "gcc Relation Class B" ) = ggcClass ;

ggcStructureToRelations = gccRelations . Add ( ) ;
ggcStructureToClasses . RelatedItems . Item ( "gcc Relation Class A" ) = ggcStructure ;
ggcStructureToClasses . RelatedItems . Item ( "gcc Relation Class B" ) = ggcRelation ;
```

This is where objects no longer have C++ *classes*, but a C++ *object* for a class.  
The first line assigns the Structure class to the Structure object.  
The layer is called the ggc layer. The first g stands for *generic*. When you use the engine above, you will describe classes in a more generic way as CItem objects. CItem objects are considered Computer Language objects, not C++ objects. The second g also stands for generic. For the first time the engine itself is described as CItem objects, which are not considered C++ objects, but Computer Language objects. The third letter, the letter c stands for C++ and the fact that the *reflective data* of the objects used above, are still CClass objects of the ccc-layer, which are considered C++ objects, rather than a Computer Language objects.

I guess I have made clear, that it is important to understand that CItem objects are *not* considered C++ objects but generic Computer Language objects.

### About The Layers Up Until Now

The first layer is the absolute minimum Computer Language must contain. In the second layer you build up a generic version of it, but it’s still described in a way, you couldn’t describe it in a Computer Language itself. The third layer is programmed in a way, you could program it in a Computer Language programming environment. So this layer could be reprogrammed in a Computer Language programming environment.

The bottom layers will only contain the absolute base of the systematics of Computer Language: Computer Language in its most primitive form, just enough to redescribe it. All the extensions are added to the top layer, which can be reprogrammed within the Computer Language programming environment.

In theory, you could directly program the running programming environment. So in realtime you are programming the program you are programming in. Very cool, but not very practical, because if you mess up the program, you have also directly messed up the environment you were programming in. So you are going to want to use an older version of the programming environment, to make a new version with. The new programming environment can replace the older version. So you can reprogram the topmost layer within the Computer Language itself.

A part of Computer Language will never be reprogrammed within itself. In Computer Language 0.9, the generator-version, the generator itself was also never regenerated, only the part with which you describe a program. The absolute base of Computer Language will always be ‘hand written’.

### Layer 4: The ggg-Layer

The 4th layer is called the ggg-layer and looks almost exactly the same as the 3rd layer, except for the first line of code.

```c++
ggcStructure . *GenericClass* = ggcLayer . ggcStructure ;

gggStructure = ggcClasses . Add ( ) ;
gggClass = ggcClasses . Add ( ) ;
gggRelation = ggcClasses . Add ( ) ;

gggStructureToClasses = ggcRelations . Add ( ) ;
gggStructureToClasses . RelatedItems . Item ( "ggc Relation Class A" ) = gggStructure ;
gggStructureToClasses . RelatedItems . Item ( "ggc Relation Class B" ) = gggClass ;

gggStructureToClasses = ggcRelations . Add ( ) ;
gggStructureToClasses . RelatedItems . Item ( "ggc Relation Class A" ) = gggStructure ;
gggStructureToClasses . RelatedItems . Item ( "ggc Relation Class B" ) = gggRelation ;
```

When adding items, under the surface, an item gets assigned a class, upon which the item configures itself according to the class description. Only one of the assignments of a class is explicitly visible in the code above: the first line: assigning the Structure class to the Structure object.  
In the 3rd layer it was a C++ object describing the class. In the 4th layer it is a Computer Language object describing the class. So in this layer, the class descriptions used, are Computer Language objects, whereas in the previous layer the class descriptions used, were C++ objects.  
After class assignment, an object looks the same in both layers.  
The first g in ggg-layer stands for generic: the fact that the engine above will be used specifying Computer Language objects. The second g in the ggg-layer also stands for generic, but now because the engine itself is built up of generic CItem objects. The third g in the ggg-layer stands for generic, but now the fact that the reflective data of every CItem object used in the code above, is also a generic Computer Language object.

So the three letters always indicate:

- Its usage
- Its objects
- Its classes

### Generic & Non-Generic Classes

So there are two procedures in a CItem object that adapt the CItem to its class: one that takes a CClass object, that describes the class using a C++ object, and one that takes a CItem object, that describes the class Computer-Language-style.

### Summary of Layers 1 - 4

- So layer 1 provides a C++ way to define structures.
- Layer 2 describes Computer Language again, using C++ CClass objects.
- Layer 3 assigns these C++ CClass objects to CItem objects, and describes Computer Language in CItem objects, instead of CClass objects.
- Layer 4 also consists of CItem objects, but the assigned classes are CItem objects themselves.
-----
- So in the 1st layer everything is C++.
- In the 2nd layer things are CClass objects.
- In both the 3rd and the 4th layer, everything is described using CItem objects.
- The difference between the 3rd and 4th layer is, that in the 3rd layer the assigned classes are CClasses, and in the 4th layer the assigned classes of are CItems.

### Layer 5: The pgg-Layer

The 5th layer consists of custom text code, for which a text code parser is programmed. This layer is called the pgg-layer. The p stands for *parsed*. The text code is translated to a structure that is the same as the previous layer, but this is done with a custom text code as input and the output coming out of the parser. This custom text code looks something like this:

```vb
Class  Structure
Class  Class

Structure  (  Structure  )    1  -->  n    Class  (  Classes  )
Structure  (  Structure  )    1  -->  n    Relation  (  Relations  )
```

The parser will translate it to the same data as in the previous layer. But in this layer more features are added, because it is so much easier to add more features using this custom text code. So here it is, where all the extra features are added, that were left out in the layers before. It is in this layer, that you can really see that the Computer Language is being programmed within itself. And this is where it gets so much easier to program more features.  
The two g’s in the term pgg-layer stand for *generic* in the fact that the engine is still built on top of non-parsed Computer Language objects, with non-parsed Computer Language objects as reflective data.

### The ggg-Layer Not Required

The parser could (probably) also have used the 3rd layer instead of the 4th layer. The 4th layer might not even be required. It dates back to when there was no custom text code in any of the layers yet, and the 4th layer was the outermost layer in which the description of the system is exactly the same as the previous description. But now the 4th layer isn’t an end-point anymore, so it can be skipped.

### Layer 6: The ppg-Layer

There’s also a 6th layer. The code of it, is exactly the same as the 5th layer. The deal is that the extra features, that are in the text code, were added to the *objects*, but the extra features were not present in the *class descriptions* of the objects. So the objects themselves had extra elements, but their reflective data did not. To make the reflective data of the engine as rich as the objects themselves, the parser will build up the structure again using the 5th layer as reflective data, which also has all the rich features  present in it. The 6th layer is also called the ppg-layer. It is the topmost layer.

### Summary Of The Layers

A summary of all the layers:

- ccc-layer:
    - When you use this engine, you are working with C++ objects.
    - The engine itself is built up of C++ objects.
    - And their reflective data is basically just the C++ code.
- gcc-layer:
    - When you use this engine, you are working with Computer Language objects.
    - The engine itself is still built up of C++ objects.
    - And the reflective data of the C++ objects, are also C++ objects.
- ggc-layer:
    - When you use this engine, you will be working with Computer Language objects.
    - The engine itself is also built up of Computer Language objects.
    - But the class descriptions of the objects the engine is built up of, are still C++ objects.
- ggg-layer:
    - When you use this engine, you will be working with Computer Language objects.
    - The engine itself is also built up of Computer Language objects.
    - And the class descriptions of the objects the engine is built up of, are also Computer Language objects.
- pgg-layer:
    - This engine is described by a custom text code. A parser takes this text code and turns it into an engine. For the rest, things are the same as the ggg-layer.
    - This engine has richer features, but the reflective data of the engine’s objects does not have these rich features.
- ppg-layer:
    - The same as the previous layer, but now the reflective data of the objects the engine is built up of, also has all the rich features in it.

### Parsed Layers Not Required

Disregarding a few things, you don’t need the parsed layers pgg and ppg, if you agree to describe a richer Computer Language structure layer in the ggc and ggg layers, then you’d have the same engine. But then you’d be programming the engine in C++. You would have much more C++ code to write, and Computer Language is just much easier to write. It is the practicality that matters here. It is more practical to program using Computer Language code, so it’s more practical to program Computer Language using Computer Language.

### Indirection On Class Assignment

It’s not that each layer adds another layer of indirections to the Computer Language *objects*. It is the way you describe *classes* that is different in each layer. The *objects* are constructed the same way in most of the layers. Assigning a class to an object goes slower with each engine layer added, because of following more indirections.

### No Indirections On Object Access

The CItem objects are just CItem objects with each an arbitrary number of attributes, related items and related lists. It is only when assigning a class, that it has anything to do with the class description. After the class is assigned it’s just an Item with an arbitrary set of attributes, related items and related lists, independent of the class. It just looks like it conforms to the class it was assigned, but the Item really has no connection with it anymore.

Not regarding the class assignment, the structure even in the highest layer basically consists of CItem objects with arbitrary sets of attributes, related items, and related lists.

### How Data Is Stored

Object access does not have any extra indirections due to the the multiple layers. Data is mostly just stored as Computer Language objects, that can have an arbitrary set of attributes, related items and related lists.

It’s not the data that is redescribed six times. It is class descriptions, that is redescribed six times. Data are just Items, that can configure themselves using a Class or Generic Class.

In the 1st layer the *data*, that is the structure description, is *the C++ code*. In the 2nd layer the structure description is C++ objects in memory. In the 3rd and 4th layers the structure description actually consists of Computer Language objects, that can become memory based or disk based data. The data in both layers is pretty much the same. The difference between the 3rd and 4th layer, is that in the 4th layer, the structure/classes of the Computer Language data are described by yet again Computer Language data, and in the 3rd layer, the structure/classes of the Computer Language data are described by memory based C++ objects. The data in the two parsed creator layers on top of that, is also the same, yet richer, because more features are added to the engine programmed in custom text code.

### Layer 7 Is For Fun

For fun you can add another layer, where you describe Computer Language as Computer Language data. But this layer would only be there for fun and not *required* nor more practical in order to accomplish Computer Language Programmed Within Itself.

### Slowing Down On Each Added Layer

I used to have a test where I parsed the custom text code of the Computer Language, and then replaced the currently running Computer Language engine by the one just parsed. It did not give errors, but as I repeatedly parsed and replaced the engine, the system became slower and slower exponentially.

An extra Computer Language engine layer does not cause extra redirections on item access, but it does cause redirections in the class definitions. These classes were used when looking for an item by name. So that made item access also go slower with each added Computer Language engine layer too.

To make object access by name not go slower with each engine layer, the name of the object was stored in the object, not just in the class. That ensured the disconnection from the class after class assignment, so that the data had nothing to do anymore with how many layers the engine has. You would still have to loop through all the items, to look for an item by name, but not through multiple Computer Language engine layers anymore, only through one layer. It dramatically improved performance.  
It also speeded up class assignment, because class assignment also looked up items by name.

If you index items purely by number, then you also don’t have to search for names anymore. That would be very nice.

### Ideas

Computer Language, Code Base

- Rename 'Your' and 'My' to ccc and gcc naming
- Also rename the identifiers in the first layer to ccc
    - \> That will make a lot of code look crappy, because then members such as RelatedItems will always be called cccRelatedItems.  
    What you should do is not apply that naming for the items, only for the structure

JJ

-----

Computer Language, Code Base

I doubt, that the ggg layer is required.  
I think the pgg layer could also be built on top of the ggc layer.
The reason this layer existed, is because at first there were no p-layers.

JJ

-----

Computer Language, Code Base

Make the item part of the deepest layer a separate code module, because it is not part of the layering. It is always present.

It is a layering of class descriptions. Actual items of data are always the same regardless of the layer. This is analogous to the generator-version, which could regenerate the module used for structure descriptions, but could not regenerate the part actually generating the code.

JJ

-----

Computer Language, Code Base

Could I omit Computer Language layers, by taking the ppg layer and somehow linking it to the gcc layer, and throw away the intermediate layers, so that only 3 layers remain?
I’m not sure.

JJ

-----

- Classes need to be part of the code base in order to rewrite the code base several times.
    - Classes misschien toch niet nodig in code base
        - Als ook de code base geen classes heeft, hoef je classes ook niet te herprogrammeren in lagen daarboven. Pas op het eind implementeren als Concept?  
        Dit gaat over het onderwerp implementation as a concept: een ander project. Niet belangrijk nu, wat principle is en wat concept.

-----

Code Base, Objects,

For relation between objects, you only need two unary relations, that are not synchronized. An object has a list of referrers in it, and an item in it, that says which other object it refers to.

You only need relation between objects for the concept of classes, if you make the concept of classes a dual relation: a class also needs to be aware of all the objects that use it as its class.  
If you accept, that a class does not know which objects use it as its class, then you don’t even need relations between objects to be dual. You’s only need sub objects, that refer to another object.

But you already need to implement sub objects and sub lists in the code base in order to have any kind of multiplicity, don’t you?  
Actually, that is not important enough for now. For now it is not important to brainstorm about what is a principle, what is a concept, and how much needs to be put in the code base.

The code base probably only needs unary relations between objects. The highest layers on top of the code base, can turn this into dual relations between objects, but the lowest layer only needs unary relations.

JJ

-----

Code Base,  
Reference as a Concept,  
2008-06-23

If a sub object either is a reference, or a value, can a reference be implemented as a binary value. Could the principle of Values facilitate the principle of reference?

It only applies, that a sub-object is either a reference or a value, when an attribute never contains sub-objects, only a value.

JJ

-----

Code Base,

What if a machine instruction becomes a command object with a binaral? The binaral is an instruction executable by the CPU. Does this open up possibilities to take even more out of the code base?

JJ

-----

Code Base,  
2008-06-24

Can you implement reference assignments as calls to machine instructions, executed within the programming language itself?

JJ

-----

Code Base,  
Redirections are established with assignments,  
2008-08-07

< 2008-09-02 This is considered a code base idea, because it makes redirections be able to build on value assignment. >

You have to explain how lines or redirections are established with an assignment, and that this happens automatically when for instance, when instantiating objects of a class. The assignment, even though you don’t see it, is executed by the direct mutual parent.

JJ

-----

Computer Language Programmed Within Itself,  
2008-08-27

The code base is the minimal needs, that need to be programmed in another programming language, required to be able to fully reprogram that code base using the new programming language itself.

JJ

-----

Code Base,  
Advanced Command Articles,  
2008-08

When machine instructions are invoked in the new computer language as calls to new computer language commands, that invoke the instruction, then a string of such machine instructions has a real overhead around it. Therefore, pure stretches of assembly commands calls should be packed in a clause, that gets a binaral that is the exact machine code, compiled as a stretch of binary, instead of separate ‘symbol’ commands. That should take care of the overhead, when writing deep-core assembly stuff.

JJ

-----

You can program at the lowest level from within the new computer language, because you can call machine instructions and compile a command to a runnable binary. So you could program a kernel using the programming language itself. So a kernel is not required to be able to program a kernel using the new computer language.